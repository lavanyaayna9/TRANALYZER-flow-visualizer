\IfFileExists{t2doc.cls}{
    \documentclass[documentation]{subfiles}
}{
    \errmessage{Error: could not find t2doc.cls}
}

\begin{document}

\trantitle
    {socketSink}
    {Output Into a TCP/UDP Socket}
    {Tranalyzer Development Team}

\section{socketSink}\label{s:socketSink}

\subsection{Description}
This plugin is a socket interface of Tranalyzer. The idea is to interface one or many distributed Tranalyzer instances
with a central server post-processing and visualizing its data. The plugin also implements the Alarm Mode being activated
by {\tt ALARM\_MODE=1} in the core {\em tranalyzer.h} file. Prepending information such as data length, checksum, or an id is controlled by the
{\tt BUF\_DATA\_SHFT} variable in the Tranalyzer core: {\em outputBuffer.h}. The user needs to configure the destination port, socket type
and whether host info is transmitted in the first record. The socketSink plugin produces output directly into the Ethernet interface.

\subsection{Dependencies}

\subsubsection{External Libraries}
If gzip compression is activated ({\tt SKS\_GZ\_COMPRESS=1}), then {\bf zlib} must be installed.
\begin{table}[!ht]
    \centering
    \begin{tabular}{>{\bf}r>{\tt}l>{\tt}l}
        \toprule
                                     &                      & {\bf SKS\_GZ\_COMPRESS=1}\\
        \midrule
        Ubuntu:                      & sudo apt-get install & zlib1g-dev\\
        Arch:                        & sudo pacman -S       & zlib\\
        Gentoo:                      & sudo emerge          & zlib\\
        openSUSE:                    & sudo zypper install  & zlib-devel\\
        Red Hat/Fedora\tablefootnote{If the {\tt dnf} command could not be found, try with {\tt yum} instead}:
                                     & sudo dnf install     & zlib-devel\\
        macOS\tablefootnote{Brew is a packet manager for macOS that can be found here: \url{https://brew.sh}}:
                                     & brew install         & zlib\\
        \bottomrule
    \end{tabular}
\end{table}

\subsubsection{Core Configuration}
This plugin requires the following core configuration:
\begin{itemize}
    \item {\em \$T2HOME/tranalyzer2/src/tranalyzer.h}:
        \begin{itemize}
            \item {\tt BLOCK\_BUF=0}
        \end{itemize}
\end{itemize}

\subsection{Configuration Flags}
The following flags can be used to control the output of the plugin:

%\subsection{socketSink.h}
\begin{longtable}{>{\tt}lcl>{\tt\small}l}
    \toprule
    {\bf Name} & {\bf Default} & {\bf Description} & {\bf Flags}\\
    \midrule\endhead%
    SKS\_SERVADD       & {\tt\small "127.0.0.1"} & destination address                & \\
    SKS\_DPORT         & 6666                    & destination port (host order)      & \\
    SKS\_SOCKTYPE      & 1                       & Socket type: 0: UDP; 1: TCP        & \\
    SKS\_GZ\_COMPRESS  & 0                       & Compress (gzip) the output         & SKS\_SOCKTYP=1\\
    SKS\_CONTENT\_TYPE & 1                       & 0: binary; 1: text; 2: JSON        & \\
    SKS\_HOST\_INFO    & 0                       & 0: no info; 1: all info about host & SKS\_CONTENT\_TYPE=0\\
    \bottomrule
\end{longtable}

\subsubsection{bin2txt.h}
{\tt bin2txt.h} controls the conversion from internal binary format to standard text output.

\begin{longtable}{>{\tt}lcl>{\tt\small}l}
    \toprule
    {\bf Variable} & {\bf Default} & {\bf Description} & {\bf Flags}\\
    \midrule\endhead%
    HEX\_CAPITAL          & 0 & Hex number representation:                     & \\
                          &   & \qquad 0: lower case,                          & \\
                          &   & \qquad 1: upper case                           & \\
    IP4\_NORMALIZE        & 0 & IPv4 addresses representation:                 & \\
                          &   & \qquad 0: normal,                              & \\
                          &   & \qquad 1: normalized (padded with 0)           & \\
    IP6\_COMPRESS         & 1 & IPv6 addresses representation:                 & \\
                          &   & \qquad 0: full 128 bit length                  & \\
                          &   & \qquad 1: compressed                           & \\
    TFS\_EXTENDED\_HEADER & 0 & Print an extended header in the flow file      & \\
                          &   & \qquad (number of rows, columns, columns type) & \\
    B2T\_LOCALTIME        & 0 & Time representation:                           & \\
                          &   & \qquad 0: UTC,                                 & \\
                          &   & \qquad 1: localtime                            & \\
    B2T\_NANOSECS         & 0 & Time precision:                                & \\
                          &   & \qquad 0: microsecs,                           & \\
                          &   & \qquad 1: nanosecs                             & \\
    HDR\_CHR              & {\tt\small "\%"}
                              & start character of comments in flow file       & \\
    SEP\_CHR              & {\tt\small "\textbackslash{}t"}
                              & character to use to separate the columns in the flow file & \\
    \bottomrule
\end{longtable}

\subsubsection{Environment Variable Configuration Flags}
The following configuration flags can also be configured with environment variables ({\tt ENVCNTRL>0}):
\begin{itemize}
    \item {\tt SKS\_SERVADD}
    \item {\tt SKS\_DPORT}
\end{itemize}

\subsection{Additional Output}
The output buffer normally being written to the flow file will be directed to the socket.\\

If {\tt SKS\_HOST\_INFO=1} then the following header is transmitted as a prelude.

\begin{longtable}{rll>{\tt\small}l}
    \toprule
    {\bf Parameter} & {\bf Type} & {\bf Description} & {\bf Flags}\\
    \midrule\endhead%
    1 & U32     & Message length                                         & BUF\_DATA\_SHFT>0 \\
    2 & U32     & Checksum                                               & BUF\_DATA\_SHFT>1 \\
    3 & U32     & Sensor ID                                              & \\
    4 & U64.U32 & Present Unix timestamp                                 & \\
    5 & RS      & OS;Machine Name;built;OS type;HW;                      & \\
    6 & RS      & Ethername(address) or IPInterfacename(address/netmask) & \\
    \bottomrule
\end{longtable}

After the prelude all flow based binary buffer will be directed to the socket interface according to the format shown in the following table:

\begin{longtable}{rll>{\tt\small}l}
    \toprule
    {\bf Column} & {\bf Type} & {\bf Description} & {\bf Flags}\\
    \midrule\endhead%
    1 & U32  & Message length       & BUF\_DATA\_SHFT>0 \\
    2 & U32  & Checksum             & BUF\_DATA\_SHFT>1 \\
    3 & RU32 & Binary buffer output & \\
    \bottomrule
\end{longtable}

\subsection{Example}

\begin{enumerate}
    \item Open a socket, e.g., with netcat: {\tt nc -l 127.0.0.1 6666}
    \item Start T2 with the socketSink plugin, e.g., {\tt t2 -r file.pcap}
    \item You should now see the flows on your netcat terminal
\end{enumerate}

To simulate a server collecting data from many T2 or save the transmitted flows into a file, use the following command:
{\tt nc -l 127.0.0.1 6666 > flowfile.txt}

\subsection{Post-Processing}

\subsection{t2b2t}
The program {\tt t2b2t} can be used to transform binary Tranalyzer files generated by the \tranrefpl{binSink} or \tranrefpl{socketSink} plugin into text or JSON files.
The converted files use the same format as the ones generated by the \tranrefpl{txtSink} or \tranrefpl{jsonSink} plugin.\\

The program can be found in {\tt\$T2HOME/utils/t2b2t} and can be compiled by typing {\tt make}.\\

The use of the program is straightforward:
\begin{itemize}
    \item bin$\rightarrow$txt: {\tt t2b2t -r FILE\_flows.bin -w FILE\_flows.txt}
    \item bin$\rightarrow$JSON: {\tt t2b2t -r FILE\_flows.bin -j -w FILE\_flows.json}
    \item bin$\rightarrow$compressed txt: {\tt t2b2t -r FILE\_flows.bin -c -w FILE\_flows.txt.gz}
    \item bin$\rightarrow$compressed JSON: {\tt t2b2t -r FILE\_flows.bin -c -j -w FILE\_flows.json.gz}
\end{itemize}

If the {\tt --w} option is omitted, the destination is inferred from the input file, e.g., the examples above would produce the same output files with or without the {\tt --w} option. Note that {\tt --w --} can be used to output to stdout.\\
Additionally, the {\tt --n} option can be used {\bf not} to print the name of the columns as the first row.\\
Try {\tt t2b2t -h} for more information.

\end{document}
