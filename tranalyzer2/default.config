# [!!! -------------------------------------------------------------------- !!!]
# [!!! ---------------------- DO NOT EDIT THIS FILE ----------------------- !!!]
# [!!! -------------------------------------------------------------------- !!!]
#
# This is the default configuration for tranalyzer2
#
# Apply the configuration as follows:
#     - t2conf tranalyzer2 --reset
#
# If you want to customize the default configuration, proceed as follows:
#     1. Create 'tranalyzer2.config':
#           t2conf tranalyzer2 -g
#     2. Edit 'tranalyzer2.config'
#     3. Apply 'tranalyzer2.config':
#           t2conf tranalyzer2 -C tranalyzer2.config
#
# [Format of the file]
#     - Empty lines and lines starting with '%' or '#'â€™ are ignored.
#     - One section starting with '# :name: pluginName' per file.
#     - If no section starting with '# :file: path/to/file.h" is specified,
#       it is assumed the file is src/pluginName.h (relative to plugin folder)
#         - If a configuration element applies to a different file, a file
#           section MUST be used
#         - Filenames are relative to plugin folder, i.e., tranalyzer2,
#           e.g., src/tranalyzer.h
#     - A line is composed of the name of a macro (define) in the header file
#       followed by an equal sign and the value to set for the define:
#           NAME = value
#       where value can be anything, including yes (= 1) and no (= 0)
#     - Add a comment before each setting to describe the configuration option
#       and its valid values:
#           # Description of the option [yes / no]
#       or
#           # Description of the option [0 - 255]
#       or
#           # Description of the option:
#           #   0: description of value 0
#           #   1: description of value 1
#           #   2: description of value 2

# ---------------------------------------------------------------------------- #
# :name: tranalyzer2                                                           #
# ---------------------------------------------------------------------------- #

# ---------------------------------------------------------------------------- #
# :file: src/hashTable.h                                                       #
# ---------------------------------------------------------------------------- #

# Hash function to use:
#    0: standard
#    1: Murmur3 32-bits
#    2: Murmur3 128-bits (truncated to 64-bits)
#    3: xxHash 32-bits
#    4: xxHash 64-bits
#    5: XXH3 64-bits
#    6: XXH3 128-bits (truncated to lower 64-bits)
#    7: CityHash64
#    8: MUM-hash version 3 64-bits
#    9: hashlittle 32-bits
#   10: wyhash 64-bits
#   11: FastHash32
#   12: FastHash64
#   13: t1ha0 (Linux only) [meson build backend only]
#   14: t1ha2 [meson build backend only]
T2_HASH_FUNC = 10

# Print debug information [yes / no]
HASHTABLE_DEBUG = no

# Maximum length of a hashTable's name [0 - 255]
HASHTABLE_NAME_LEN = 7

# ---------------------------------------------------------------------------- #
# :file: src/ioBuffer.h                                                        #
# ---------------------------------------------------------------------------- #

# Input buffering (store packets in a queue) [yes / no]
# Useful in live sniffing if there is a (short) packet burst
IO_BUFFERING = no

# number of ms to wait if queue is full
IO_BUFFER_FULL_WAIT_MS = 200

# max number of packets that can be stored in the buffer
# (power of two is faster)
IO_BUFFER_SIZE = 8192

# max size of a packet (divisible by 4)
IO_BUFFER_MAX_MTU = 2048

# ---------------------------------------------------------------------------- #
# :file: src/loadPlugins.h                                                     #
# ---------------------------------------------------------------------------- #

# Behavior of -b option (plugin loading list):
#   0: disable -b option and load all plugins from the plugin folder,
#   1: only load plugins present in the list (whitelist),
#   2: do not load plugins present in the list (blacklist)
USE_PLLIST = 1

# default filename for plugin white-/black-list (-b option)
PLLIST = "plugins.txt"

# ---------------------------------------------------------------------------- #
# :file: src/main.h                                                            #
# ---------------------------------------------------------------------------- #

# Packet mode (-s option)

# Print the packet number [yes / no]
SPKTMD_PKTNO = yes

# Print payload as characters [yes / no]
SPKTMD_PCNTC = yes

# Print payload as hex [yes / no]
SPKTMD_PCNTH = no

# Content field in packet mode:
#   0: Print the full payload of the packet
#   1: Print payload from L2
#   2: Print payload from L3
#   3: Print payload from L4
#   4: Print payload from L7
SPKTMD_PCNTL = 4

# Bit operations on content:
#   0x00: MSB
#   0x01: LSB, bit inverse
#   0x02: Nibble swap
#   0x10: Shift right
#   0x20: if 0x10: shift from last byte into extra byte
SPKTMD_BOPS = 0x00

# Shift SPKTMD_BSHFT_POS-1 at 8-SPKTMD_BSHFT into following bytes [0 - 255]
SPKTMD_BSHFT_POS = 5

# Bitshift [0 - 255]
# (require (SPKTMD_BOPS & 0x10))
SPKTMD_BSHFT = 2

# Prefix to add to every byte in packet mode as hex ("" -> ab cd instead of 0xab 0xcd)
# (require SPKTMD_PCNTH = yes)
SPKTMD_PCNTH_PREF = "0x"

# Byte separator in packet mode as hex ("," -> 0xab,0xcd instead of 0xab 0xcd)
# (require SPKTMD_PCNTH = yes)
SPKTMD_PCNTH_SEP = " "

# Monitoring mode

# Threaded interrupt handling [yes / no]
MONINTTHRD = yes

# Block interrupts in main loop during packet processing, disable MONINTTHRD [yes / no]
MONINTBLK = no

# Synchronized print statistics [yes / no]
MONINTPSYNC = yes

# Time-base for monitoring:
#   0: real time base
#   1: pcap time base
MONINTTMPCP = 0

# Automatic start of monitoring [yes / no]
# (require MONINTTMPCP = 0)
MONINTTMPCP_ON = no

# Interval (seconds) of monitoring output (0 to disable) [0 - float_max]
MONINTV = 1.0

# On SIGUSR1, read T2MTIM environment variable and set monitoring timer to it [yes / no]
POLLENV = no

# Monitoring mode protocol stat

# Monitoring report protocol format:
#   0: Protocol numbers
#   1: Protocol names (L3 only)
MONPROTMD = 1

# Layer 2 protocols to monitor
MONPROTL2 = ETHERTYPE_ARP,ETHERTYPE_RARP

# Layer 4 protocols to monitor
MONPROTL3 = L3_TCP,L3_UDP,L3_ICMP,L3_ICMP6,L3_SCTP

# File containing protocols description
MONPROTFL = "proto.txt"

# Use DPDK multi-process mode instead of libpcap
DPDK_MP = 0

# Output min max bandwidth statistics [yes / no]
MIN_MAX_ESTIMATE = no

# Min Max interval (secs) [0 - FLOAT_MAX]
MMXLAGTMS = 0.1

# Suppress 0 content in MIN estimation [yes / no]
MMXNO0 = no

# ---------------------------------------------------------------------------- #
# :file: src/networkHeaders.h                                                  #
# ---------------------------------------------------------------------------- #

# IP version(s) to dissect:
#   0: IPv4 only,
#   1: IPv6 only,
#   2: dual mode
IPV6_ACTIVATE = 2

# Handling of layer 2 flows:
#   0: No Ethernet flows,
#   1: Activate Ethernet flows,
#   2: Also use Ethernet addresses for IPv4/6 flows
ETH_ACTIVATE = 1

# Create one flow per LAPD streams [yes / no]
LAPD_ACTIVATE = no

# LAPD over UDP:
#   0: Do not try dissecting LAPD over UDP
#   1: Dissect LAPD over UDP (experimental)
# (require LAPD_ACTIVATE=1)
LAPD_OVER_UDP = no

# Create one flow per SCTP streams:
#   0: standard flows
#   1: activate SCTP chunk streams -> flows
#   2: activate SCTP association -> flows
#   3: activate SCTP streams & association -> flows
SCTP_ACTIVATE = 0

# Handling of SCTP flows:
#   0: findex increments
#   1: findex constant for all SCTP streams in a packet
SCTP_STATFINDEX = 1

# Multi-packet suppression [yes / no]
MULTIPKTSUP = no

# Keep track of the headers traversed [yes / no]
T2_PRI_HDRDESC = yes

# Aggregate repetitive headers, e.g., vlan{2} instead of vlan:vlan [yes / no]
T2_HDRDESC_AGGR = yes

# max length of the headers description
T2_HDRDESC_LEN = 128

# ---------------------------------------------------------------------------- #
# :file: src/outputBuffer.h                                                    #
# ---------------------------------------------------------------------------- #

# adds for each binary output record the length and
# shifts the record by n uint32_t words to the right
# (see binSink and socketSink plugins)
BUF_DATA_SHFT = 0

# Automatically increase the output buffer when required [yes / no]
OUTBUF_AUTOPILOT = yes

# Maximal factor to increase the output buffer size to
# (f * MAIN_OUTBUF_SIZE)
OUTBUF_MAXSIZE_F = 5

# ---------------------------------------------------------------------------- #
# :file: src/packetCapture.h                                                   #
# ---------------------------------------------------------------------------- #

# Interpretation of packet length:
#   0: including L2, L3 and L4 header,
#   1: including L3 and L4 header,
#   2: including L4 header,
#   3: only higher layer payload (Layer 7)
PACKETLENGTH = 3

# Handling of IP header for fragmented packets:
#   0: IP header stays with 2nd++ fragmented packets,
#   1: IP header stripped from 2nd++ fragmented packets
FRGIPPKTLENVIEW = 1

# Position of layer 3 header:
#   0: Automatic L3 header discovery
#   1: Manual L3 header positioning
NOLAYER2 = 0

# Offset of L3 header (require NOLAYER2 = 1)
NOL2_L3HDROFFSET = 0

# Maximal header count for IPv6 [3 - 255]
MAXHDRCNT = 5

# Enable sending FL_ALARM for pcapd [yes / no]
SALRM = no

# Invert selection [yes / no]
# (require SALRM = 1)
SALRMINV = no

# ---------------------------------------------------------------------------- #
# :file: src/proto/capwap.h                                                    #
# ---------------------------------------------------------------------------- #

# Swap CAPWAP frame control [yes / no]
# (required for Cisco)
CAPWAP_SWAP_FC = yes

# ---------------------------------------------------------------------------- #
# :file: src/proto/ethertype.h                                                 #
# ---------------------------------------------------------------------------- #

# Detect Pseudowire (PW) Ethernet Control Word (Heuristic, experimental) [yes / no]
PW_ETH_CW = yes

# ---------------------------------------------------------------------------- #
# :file: src/proto/linktype.h                                                  #
# ---------------------------------------------------------------------------- #

# Dissect PCAP with Juniper linktypes (Experimental) [yes / no]
LINKTYPE_JUNIPER = yes

# ---------------------------------------------------------------------------- #
# :file: src/proto/lwapp.h                                                     #
# ---------------------------------------------------------------------------- #

# Swap LWAPP frame control [yes / no]
# (required for Cisco)
LWAPP_SWAP_FC = yes

# ---------------------------------------------------------------------------- #
# :file: src/tranalyzer.h                                                      #
# ---------------------------------------------------------------------------- #

# Sensor ID (can be overwritten with -x option) [0 - UINT16_MAX]
T2_SENSORID = 666

# Plugins configuration mode:
#   0: Use values from header file during compilation
#   1: Use values from header file at runtime
#   2: Use values from the environment if defined, otherwise from header file at runtime
ENVCNTRL = 2

# Folder to load plugins from (can be set with -p option)
PLUGIN_FOLDER = ".tranalyzer/plugins/"

# -D option parameters

# Round robin operation [yes / no]
RROP = no

# Poll timing in seconds for files
POLLTM = 5

# FIXME description is not clear:
#   > 0: timeout for poll timing > POLLTM
#   0: no poll timeout
MFPTMOUT = 0

# separating char for number (refer to the doc for examples)
#SCHR = 'p'

# -W option parameters

# Default fragmented output file length (500MB)
OFRWFILELN = 5e8

# alive signal activation

# Activate alive mode [yes / no]
REPSUP = no

# Name of control program
ALVPROG = "t2alive"

# Alive and stall USR1 signal (no packets count)
#REPCMDAS = "a=`pgrep " ALVPROG "`; if [ $a ]; then kill -USR1 $a; fi"

# Alive and well USR2 signal (working)
#REPCMDAW = "a=`pgrep " ALVPROG "`; if [ $a ]; then kill -USR2 $a; fi"

# PID file

# Enable PID -> file [yes / no]
PID_FNM_ACT = no

# Filename for PID file
PID_FNM = "tranalyzer.pid"

# Suffix for the packet file (-s option)
PACKETS_SUFFIX = "_packets.txt"

# Suffix for the log file (-l option)
LOG_SUFFIX = "_log.txt"

# Suffix for the monitoring file (-m option)
MON_SUFFIX = "_monitoring.txt"

# Compute statistics about time spent in perPacketCallback() [yes / no]
PKT_CB_STATS = no

# Debug level:
#   0: no debug output
#   1: debug output which occurs only once or very seldom (i.e. initialize stuff, errors, ...)
#   2: + debug output which occurs in special situations, but not regularly (i.e. border conditions, restructure works, ...)
#   3: + debug output which occurs regularly (i.e. every packet)
DEBUG = 0

# Verbose level of final report:
#   0: no output
#   1: Basic pcap report
#   2: + full traffic statistics
#   3: + info about frag anomalies
VERBOSE = 2

# Enable memory debug of buffers on the heap (allocated with malloc or calloc) [yes / no]
MEMORY_DEBUG = no

# Timing ops

# If no packets are available for processing, sleep some time in us
NO_PKTS_DELAY_US = 1000

# Activate non blocking mode of pcap_dispatch [yes / no]
# (This is necessary when using the CTRL+C keystroke feature and complete flows are expected)
NON_BLOCKING_MODE = yes

# Flow output buffer

# Size of the main output buffer
MAIN_OUTBUF_SIZE = 1000000

# pcap
SNAPLEN = 65535

# pcap (TODO should we leave this here?)
#CAPTURE_TIMEOUT = 1000

# Optimize BPF filters [yes / no]
BPF_OPTIMIZE = no

# Timestamp precision:
#   0: Microsecs,
#   1: Nanosecs
TSTAMP_PREC = 1

# Time representation:
#   0: Localtime,
#   1: UTC
TSTAMP_UTC = 1

# Time report representation:
#   0: Localtime,
#   1: UTC
TSTAMP_R_UTC = 0

# Tranalyzer User Operational modes

# Operation modes, Plugins which use these modes have to be recompiled

# Only flow output if an alarm based plugin fires [yes / no]
ALARM_MODE = no

# FIXME description is not clear:
#   0: OR
#   1: AND
# (require ALARM_MODE = 1)
ALARM_AND = 0

# NetFlow mode: parameter induced flow termination, implemented by plugins [yes / no]
FORCE_MODE = no

# Block unnecessary buffer output when non tranalyzer format event-based plugins are active: e.g. Syslog, ArcSight [yes / no]
BLOCK_BUF = 0

# Use t2Bus communication backend (experimental) [yes / no]
#USE_T2BUS = no

# End report / monitoring: USR1/2 interrupts

# Enable plugins to contribute to the tranalyzer command line end report [yes / no]
PLUGIN_REPORT = yes

# FIXME description is not clear:
#   0: Absolute tranalyzer command line USR1 report
#   1: Differential
DIFF_REPORT = 0

# FIXME description is not clear:
#   0: Human compliant
#   1: Machine compliant
MACHINE_REPORT = 0

# state save mode: findex, report and statistical data

# Store statistical report history after shutdown and reload it when restarted [yes / no]
REPORT_HIST = no

# Statistical report history filename
REPORT_HIST_FILE = "stat_hist.txt"

# Allow the classifiers to globally access dependent plugin variables [yes / no]
ESOM_DEP = no

# Protocol stack

# Activate AYIYA processing [yes / no]
AYIYA = yes

# Activate GENEVE processing [yes / no]
GENEVE = yes

# Activate TEREDO processing [yes / no]
TEREDO = yes

# Activate L2TP processing [yes / no]
L2TP = yes

# Activate GRE processing [yes / no]
GRE = yes

# Activate GTP processing [yes / no]
GTP = yes

# Activate VXLAN processing [yes / no]
VXLAN = yes

# Activate IPv4/6 in IPv4/6 processing [yes / no]
IPIP = yes

# Activate Ethernet over IP processing [yes / no]
ETHIP = yes

# Activate CAPWAP processing [yes / no]
CAPWAP = yes

# Activate LWAPP processing [yes / no]
LWAPP = yes

# Activate DTLS processing [yes / no]
DTLS = yes

# Activate fragmentation processing [yes / no]
FRAGMENTATION = yes

# Enable crafted packet processing (header missing, senseless flags etc) [yes / no]
# (require FRAGMENTATION = 1)
FRAG_HLST_CRFT = yes

# Dump flawed fragmented packet info on commandline for time-based identification [yes / no]
# (WARNING: if FRAG_HLST_CRFT != 0 then every headerless frag packet in a flow is reported!)
# (require FRAGMENTATION = 1)
FRAG_ERROR_DUMP = 0

# Interpret bogus IPvX packets and pack them into IPv4 or IPv6 flows [yes / no]
IPVX_INTERPRET = no

# Anonymize (do not output) IP information [yes / no]
ANONYM_IP = no

# Layer 2 type to use for the statistics:
#   0: use the innermost
#   1: use the outermost
ETH_STAT_MODE = 0

# Subnet core control [yes / no]
SUBNET_ON = yes

# Flow Aggregation
#   L4PROT  = 0x01
#   DSTPORT = 0x02
#   SRCPORT = 0x04
#   DSTIP   = 0x08
#   SRCIP   = 0x10
#   VLANID  = 0x20
#   SUBNET  = 0x80
AGGREGATIONFLAG = 0x00

# FIXME description is not clear
# src IPv4 aggregation CIDR mask
SRCIP4CMSK = 24

# FIXME description is not clear
# dst IPv4 aggregation CIDR mask
DSTIP4CMSK = 24

# FIXME description is not clear
# src IPv6 aggregation CIDR mask
SRCIP6CMSK = 120

# FIXME description is not clear
# dst IPv6 aggregation CIDR mask
DSTIP6CMSK = 120

# FIXME description is not clear
# src port lower bound
SRCPORTLW = 1

# FIXME description is not clear
# src port upper bound
SRCPORTHW = 1024

# FIXME description is not clear
# dst port lower bound
DSTPORTLW = 1

# FIXME description is not clear
# dst port upper bound
DSTPORTHW = 1024

# Time mode

# Relative time to beginning of pcap, so time=0 at first packet or actual time
#   0: Absolute time
#   1: Relative internal time
RELTIME = 0

# Maximum lifetime of a flow:
#     0: no maximum lifetime
#   > 0: forced flow life span of n +- 1 seconds
FDURLIMIT = 0

# Flow index definition of subflows when FDURLIMIT > 0
#   0: Different findex
#   1: Same findex for flows of a superflow
# (require FDURLIMIT > 0)
FDLSFINDEX = 0

# The standard timeout for a flow in seconds [0 - UINT32_MAX]
# flow timeout after a packet is not seen after n seconds
FLOW_TIMEOUT = 182

# SIGINT 1 create no flow
NOFLWCRT = 1

# Zero packet on interface update actTime, cycle LRU list and release flows if timeout
#   0: update only if packets received
#   1: zero packet actTime update active
ZPKTITMUPD = 1

# Number of loops until actTime update
# (require ZPKTITMUPD = 1)
ZPKTTMO = 1500

# The sizes of the hash table

# Default multiplication factor for HASHTABLE_BASE_SIZE if no -f option
HASHFACTOR = 1

# Default multiplication factor for HASHCHAINTABLE_BASE_SIZE
HASH_CHAIN_FACTOR = 2

# Avoid overrun of main hash by flushing oldest NUMFLWRM flow(s) when hashTable is full [yes / no]
HASH_AUTOPILOT = yes

# Number of flows to flush when main hash map is full
# (require HASH_AUTOPILOT = 1)
NUMFLWRM = 1
