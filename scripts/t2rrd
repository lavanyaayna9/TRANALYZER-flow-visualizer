#!/usr/bin/env bash
#
# - To create and populate a RRD database, pipe the script to tranalyzer
#   (in monitoring mode) as follows:
#       - Live: t2 -i eth0 | t2rrd -m
#       - Pcap: t2 -r file.pcap | t2rrd -m
#
# - To plot one or two field(s) out of a rrd database:
#       - t2rrd field1
#       - t2rrd field1 field2

source "$(dirname "$0")/t2utils.sh"

usage() {
    printf "Usage:\n"
    printf "    $SNAME [OPTION...] [FIELD1] [FIELD2]\n"
    printf "\n"
    printf "Monitoring arguments:\n"
    printf "    -m          create and populate a database [default: $DB]\n"
    printf "    -k          append data to existing database [default: create a new DB]\n"
    printf "\n"
    printf "Plotting arguments:\n"
    printf "    -p name     name of the PNG to generate [default: field1[_field2].png]\n"
    printf "    -r WxH      size of the generated PNG (width x height) [default: 640x480]\n"
    printf "\n"
    printf "    -s start    start time of the plot [default: end-10m]\n"
    printf "                (use special value 'first' to plot from the first record)\n"
    printf "    -e end      end time of the plot [default: last]\n"
    printf "                (use special value 'last' to plot until the last record)\n"
    printf "    -i int      interval to plot [default: 10m (last 10min)]\n"
    printf "                ([s]econds, [m]inutes, [h]ours, [d]ays, [w]eeks, [mo]nth, [y]ear)\n"
    printf "    -a          plot the whole database\n"
    printf "\n"
    printf "    -U int      update the plot every 'int' seconds [default: 1]\n"
    printf "    -n          generate a fixed plot for the given interval and exit\n"
    printf "    -R          real-time: plot regular intervals (see -U option)\n"
    printf "                [default: plot to the last update]\n"
    printf "\n"
    printf "    -f          display Holt-Winters confidence bands\n"
    printf "    -t win      display the 'win' hour trend\n"
    printf "\n"
    printf "    -x          use logarithmic axis\n"
    printf "    -u max      crop values to 'max'\n"
    printf "    -l min      crop values to 'min'\n"
    printf "\n"
    printf "    -b          do not display the anteater banner\n"
    printf "\n"
    printf "Optional arguments:\n"
    printf "    -d name     name of the database [default: $DB]\n"
    printf "\n"
    printf "Help and documentation arguments:\n"
    printf "    -L          List the fields available in the database and exit\n"
    printf "    -I          display info about the database and exit\n"
    printf "    -h, --help  show this help, then exit\n"

    if [ ${#FIELDS[@]} -gt 0 ]; then
        printf "\n    FIELD1 and FIELD2 can be one of the following:\n"
        print_fields
    fi
}

print_fields() {
    local cnt=0
    for i in "${FIELDS[@]}"; do
        printf "        %-15s" "$i"
        if [ "$cnt" -eq 2 ]; then
            cnt=0
            echo
        else
            cnt=$((cnt+1))
        fi
    done
    echo
}

populate_db() {
    if [ ! -f "$DB" ]; then
        KEEP=0
    fi

    AWK -F"\t" -v db="$DB" -v k="$KEEP" '
        /^%/ {
            # Consolidation function
            AGGR = "AVERAGE"  # Take the average
            #AGGR = "MIN"     # Take the lowest value
            #AGGR = "MAX"     # Take the highest value
            #AGGR = "LAST"    # Take the last value

            # Transformation function
            TYPE = "GAUGE"      # Keep the value as input
            #TYPE = "COUNTER"   # Take the difference between the previous and the current value
            #TYPE = "ABSOLUTE"  # Divide the value by the time interval
            #TYPE = "DERIVE"    # As COUNTER, but negative values are allowed

            STEP = 1    #  1s
            #STEP = 30  # 30s
            #STEP = 60  # 1min
            #STEP = 300 # 5min

            # Holt-Winters
            # parameters can be updated later with rrdtool tune:
            #   --alpha --beta --gamma --window-length
            #   --failure-threshold --deltapos --deltaneg
            HW_FUNC = "HWPREDICT"   # additive
            #HW_FUNC = "MHWPREDICT" # multiplicative
            HW_ALPHA = 0.3          # 0: ignore the present, 1: ignore the past
            HW_BETA = 0.004         # slope/trend
            HW_GAMMA = 0.0009       # season
            HW_SP = 288             # seasonal period (seconds)
            HW_ROWS = 1440
            HW_TH = 7               # how many points out of band before failure
            HW_WL = 9               # Window length

            # First column to use for monitoring (skip report type, sensorID, time and duration)
            COLSTART = 5

            # Last to use for monitoring
            COLEND = NF

            # Column holding the time
            for (i = 1; i <= NF; i++) {
                if (tolower($i) ~ /^time$/) {
                    TIME = i
                    break
                }
            }

            if (!TIME) print "No time column found. Simulating a one second interval."

            if (k) next # reuse existing DB

            params = params " RRA:" AGGR ":0.5:1:600"   # daily
            params = params " RRA:" AGGR ":0.5:6:700"   # weekly
            params = params " RRA:" AGGR ":0.5:24:775"  # monthly
            params = params " RRA:" AGGR ":0.5:288:797" # yearly
            for (i = COLSTART; i <= COLEND; i++) {
                gsub(/[\[\]]/, "") # remove special characters: [, ]
                if ($i == "pktsRec" || $i == "pktsDrp" || $i == "ifDrp") {
                    params = params " DS:" $i ":COUNTER:5:0:U"
                } else if ($i != "globalWarn" && length($i)) {
                    params = params " DS:" $i ":" TYPE ":5:0:U"
                }
            }
            params = params " RRA:" HW_FUNC ":" HW_ROWS ":" HW_ALPHA ":" HW_BETA ":" HW_SP ":6"
            params = params " RRA:SEASONAL:" HW_SP ":" HW_GAMMA ":5"
            params = params " RRA:DEVSEASONAL:" HW_SP ":" HW_GAMMA ":5"
            params = params " RRA:DEVPREDICT:" HW_ROWS ":7"
            params = params " RRA:FAILURES:" HW_ROWS ":" HW_TH ":" HW_WL ":7"

            next
        }
        # Create new DB
        NR == 2 && !k {
            if (TIME) {
                t = $TIME
                gsub(/\.[0-9]+$/, "", t) # remove micro-/nano- seconds
            } else {
                t = "N"
            }
            params = "--start " (t-1) " --step " STEP " " params
            system("rrdtool create \"" db "\" " params)
        }
        {
            t = TIME ? $TIME : systime()

            cmd = "rrdtool update " db " "  t
            for (i = COLSTART; i <= COLEND; i++) {
                if ($i !~ /0x[0-9a-fA-F]{1,8}/ && length($i)) {
                    cmd = cmd ":" $i
                }
            }
            system(cmd)
            if (!TIME) system("sleep 1")
        }' -
}

DB="monitoring.rrd" # name of the rrd database to create/use

while [ $# -ne 0 ]; do
    case "$1" in
        -m|--monitor)
            MONITOR=1
            ;;
        -d|--database)
            validate_next_arg "$1" "$2"
            DB="$2"
            shift
            ;;
        -k|--keep)
            KEEP=1
            ;;
        -p|--png)
            validate_next_arg "$1" "$2"
            PNG="$2"
            shift
            ;;
        -r|--size)
            validate_next_arg "$1" "$2"
            if [ -z "$(AWK '/^[0-9]+x[0-9]+$/' "$2")" ]; then
                printerr "Invalid argument for option '$1': expected [width]x[height], found '$2'"
                abort_with_help
            fi
            WIDTH="$(cut -dx -f1 <<< "$2")"
            HEIGHT="$(cut -dx -f2 <<< "$2")"
            shift
            ;;
        -s|--start)
            validate_next_arg "$1" "$2"
            # Discard micro-seconds
            FSTART="$(AWK -F. '{ print $1 }' <<< "$2")"
            shift
            ;;
        -e|--end)
            validate_next_arg "$1" "$2"
            # Discard micro-seconds
            FEND="$(AWK -F. '{ print $1 }' <<< "$2")"
            shift
            ;;
        -i|--interval)
            validate_next_arg "$1" "$2"
            INTERVAL="$2"
            shift
            ;;
        -U|--update-freq)
            validate_next_arg "$1" "$2"
            UPDATE_FREQ="$2"
            shift
            ;;
        -n|--no-update)
            NOUPDATE=1
            ;;
        -R|--realtime)
            REALTIME=1
            ;;
        -a|--all)
            ALL=1
            ;;
        -f|--holt-winters)
            HW=1
            ;;
        -t)
            validate_next_arg "$1" "$2"
            WIN=$(($2*60*60))
            shift
            ;;
        -x|--log)
            LOG="--logarithmic"
            ;;
        -u|--upper-limit)
            validate_next_arg "$1" "$2"
            LIMITS="$LIMITS -u $2"
            shift
            ;;
        -l|--lower-limit)
            validate_next_arg "$1" "$2"
            LIMITS="$LIMITS -l $2"
            shift
            ;;
        -b)
            NOBANNER=1
            ;;
        -I)
            INFO=1
            ;;
        -L)
            LIST_FIELDS=1
            ;;
        -h|-\?|--help)
            HELP=1
            ;;
        *)
            # which field to plot
            if [ -z "$FIELD1" ]; then
                FIELD1="$1"
            elif [ -z "$FIELD2" ]; then
                FIELD2="$1"
            else
                abort_option_unknown "$1"
            fi
            ;;
    esac
    shift
done

check_dependency rrdtool

if [ -f "$DB" ]; then
    FIELDS=($(rrdtool info "$DB" | grep "ds\[" | cut -d[ -f2 | cut -d] -f1 | uniq))
fi

if [ -n "$HELP" ]; then
    usage
    exit 0
fi

if [ -n "$MONITOR" ]; then
    populate_db
    exit 0
fi

if [ ! -f "$DB" ]; then
    printerr "$DB is not a regular file"
    abort_with_help
elif [ ${#FIELDS[@]} -eq 0 ]; then
    printerr "$DB is not a valid RRD file"
    abort_with_help
fi

# setup image viewer
if hash feh 2> /dev/null; then
    IMAGE_VIEWER="$(which feh) --auto-zoom"
    [ -z "$NOUPDATE" ] && IMAGE_VIEWER="$IMAGE_VIEWER -R 1"
elif hash eog 2> /dev/null; then
    IMAGE_VIEWER="$(which eog)"
elif hash gthumb 2> /dev/null; then
    IMAGE_VIEWER="$(which gthumb)"
fi

if [ -z "$IMAGE_VIEWER" ]; then
    printerr "No valid image viewer found."
    printinf "Install 'feh' or 'eog'."
    exit 1
fi

FIRST="$(rrdtool first "$DB")"
LAST="$(rrdtool last "$DB")"

if [ -n "$LIST_FIELDS" ]; then
    print_fields
    exit 0
elif [ -n "$INFO" ]; then
    printf "Database: $DB\n"
    printf "First record: $FIRST\n"
    printf "Last record: $LAST\n"
    printf "Duration: $((LAST-FIRST))\n"
    printf "Fields: ${#FIELDS[@]}\n"
    print_fields
    exit 0
fi

# which field to plot
if [ -z "$FIELD1" ]; then
    FIELD1="numFlows"
fi

# make sure the field(s) exists
if [ -z "$(AWK "/\<$FIELD1\>/" <<< "${FIELDS[@]}")" ]; then
    printerr "Field '$FIELD1' does not exist"
    abort_with_help
fi

if [ "$FIELD2" ] && [ -z "$(AWK "/\<$FIELD2\>/" <<< "${FIELDS[@]}")" ]; then
    printerr "Field '$FIELD2' does not exist"
    abort_with_help
fi

# name of the output
if [ -z "$PNG" ]; then
    if [ -z "$FIELD2" ]; then
        PNG="${FIELD1}.png"
    else
        PNG="${FIELD1}_${FIELD2}.png"
    fi
fi

# resolution of the png
if [ -z "$WIDTH" ] || [ -z "$HEIGHT" ]; then
    WIDTH=640
    HEIGHT=480
fi

if [ -z "$UPDATE_FREQ" ]; then
    UPDATE_FREQ=1 # update the graph every second
fi

# Time interval to plot
if [ -z "$INTERVAL" ]; then
    INTERVAL="10min"
fi

if [ "$LIMITS" ]; then
    LIMITS="$LIMITS --rigid"
fi

init_colors() {
    # Standard colors (0: light, 1: dark)
    RED0="#EA644A"
    RED1="#CC3118"
    ORANGE0="#EC9D48"
    ORANGE1="#CC7016"
    YELLOW0="#ECD748"
    YELLOW1="#C9B215"
    GREEN0="#54EC48"
    GREEN1="#24BC14"
    BLUE0="#48C4EC"
    BLUE1="#1598C3"
    PINK0="#DE48EC"
    PINK1="#B415C7"
    PURPLE0="#7648EC"
    PURPLE1="#4D18E4"
    BLACK="#000000"
}

setup_holt_winters() {
    if [ -n "$HW" ]; then
        HOLT="DEF:pred=$DB:$FIELD1:HWPREDICT \
              DEF:dev=$DB:$FIELD1:DEVPREDICT \
              DEF:fail=$DB:$FIELD1:FAILURES \
              TICK:fail$YELLOW0:1.0 \
              AREA:obs$BLUE0 \
              CDEF:upper=pred,dev,2,*,+ \
              LINE1:upper$BLACK:\"Holt-Winters Upper Bound\l\""

            if [ -n "$FIELD2" ]; then
                HOLT="$HOLT \
                    DEF:pred2=$DB:$FIELD2:HWPREDICT \
                    DEF:dev2=$DB:$FIELD2:DEVPREDICT \
                    DEF:fail2=$DB:$FIELD2:FAILURES \
                    CDEF:nfail2=fail2,-1,* \
                    TICK:nfail2$YELLOW0:1.0 \
                    AREA:nobs2$RED0 \
                    CDEF:upper2=pred2,dev2,2,*,+ \
                    CDEF:nupper2=upper2,-1,* \
                    LINE1:nupper2$BLACK"
            fi
    fi
}

setup_trend() {
    if [ -n "$WIN" ]; then
        TREND="CDEF:trend=obs,$WIN,TREND \
               LINE2:trend$RED1:\"Trend\""

        if [ -n "$FIELD2" ]; then
            TREND="$TREND \
                CDEF:trend2=nobs2,$WIN,TREND \
                LINE2:trend2$RED1:\"Trend\""
        fi
    fi
}

setup_comments() {
    if [ -n "$FIELD2" ]; then
        COMMENT="COMMENT:\"\\u\""
    fi
    if [ -n "$HW" ]; then
        COMMENT="$COMMENT COMMENT:\"\\u\""
    fi
    if [ -n "$WIN" ]; then
        COMMENT="$COMMENT COMMENT:\"\\u\""
    fi
    COMMENT="$COMMENT COMMENT:\"\r\""
    if [ -z "$NOBANNER" ]; then
        COMMENT="$COMMENT \
            COMMENT:\"         @      @         \r\" \
            COMMENT:\"          |    |          \r\" \
            COMMENT:\"====vVv==(a    a)==vVv====\r\" \
            COMMENT:\"==========\    /==========\r\" \
            COMMENT:\"===========\  /===========\r\" \
            COMMENT:\"            oo            \r\" \
            COMMENT:\"\r\" \
            COMMENT:\"No ants were (h)armed in the making of this chart\r\""
    else
        COMMENT="$COMMENT COMMENT:\"\r\""
    fi
}

setup_field1() {
    FIELD1_S="--font DEFAULT:9: \
              --font TITLE:14: \
              --title \"$FIELD1\" \
              --vertical-label \"$FIELD1\" \
              -D -w $WIDTH -h $HEIGHT -a PNG \
              $LIMITS $LOG \
              DEF:obs=$DB:$FIELD1:AVERAGE \
              AREA:obs$BLUE0:\"$FIELD1\" \
              GPRINT:obs:LAST:\"Last\:%6.0lf%s\" \
              GPRINT:obs:AVERAGE:\"Avg\:%6.2lf%s\" \
              GPRINT:obs:MIN:\"Min\:%6.0lf%s\" \
              GPRINT:obs:MAX:\"Max\:%6.0lf%s\l\""
}

setup_field2() {
    if [ -n "$FIELD2" ]; then
        FIELD2_S="--title "$FIELD1/$FIELD2" \
                  --vertical-label \"$FIELD2/$FIELD1\" \
                  DEF:obs2=$DB:$FIELD2:AVERAGE \
                  CDEF:nobs2=obs2,-1,* \
                  AREA:nobs2$RED0:\"$FIELD2\" \
                  GPRINT:obs2:LAST:\"Last\:%6.0lf%s\" \
                  GPRINT:obs2:AVERAGE:\"Avg\:%6.2lf%s\" \
                  GPRINT:obs2:MIN:\"Min\:%6.0lf%s\" \
                  GPRINT:obs2:MAX:\"Max\:%6.0lf%s\l\""
    fi
}

init_colors
setup_holt_winters
setup_trend
setup_field1
setup_field2
setup_comments

# Convert the interval in seconds
INTERVAL="$(AWK '{
    l = split($0, t, /[^0-9]+/, seps)
    v = 0
    for (i = 1; i <= l; i++) {
        ti = t[i]
        switch (tolower(seps[i])) {
            case /^s/:                                    ; break # seconds
            case /^m(i|$)/:  ti = ti * 60                 ; break # minutes
            case /^h/:       ti = ti * 60 * 60            ; break # hours
            case /^d/:       ti = ti * 24 * 60 * 60       ; break # days
            case /^w/:       ti = ti * 7 * 24 * 60 * 60   ; break # weeks
            case /^mo/:      ti = ti * 31 * 24 * 60 * 60  ; break # months
            case /^y/:       ti = ti * 365 * 24 * 60 * 60 ; break # years
            default:
                # unknown time specification
                break
        }
        v += ti
    }
    print v
}' <<< "$INTERVAL")"

if [ "$FSTART" = "first" ]; then
    FSTART="$FIRST"
fi

if [ "$FEND" = "last" ]; then
    FEND="$LAST"
fi

if [ -n "$ALL" ]; then
    START="$FIRST"
    END="$LAST"
elif [ -n "$FSTART" ] && [ -n "$FEND" ]; then
    START="$FSTART"
    END="$FEND"
    INTERVAL="$(bc -l <<< "$FEND - $FSTART")"
elif [ -n "$FEND" ]; then
    END="$FEND"
    START="$FEND-$INTERVAL"
elif [ -n "$FSTART" ]; then
    START="$FSTART"
    END="$(bc -l <<< "$FSTART + $INTERVAL")"
else
    END="$LAST"
    START="$END-$INTERVAL"
fi

while true; do

    CMD="rrdtool graph $PNG --start $START"
    [ "$END" != "end" ] && CMD="$CMD --end $END"
    CMD="$CMD $FIELD1_S $FIELD2_S $HOLT $TREND $COMMENT"

    # Create the plot
    sh -c "$CMD" &> /dev/null

    if [ -z "$IMAGE_VIEWER_PID" ]; then
        $IMAGE_VIEWER "$PNG" 2> /dev/null &
        IMAGE_VIEWER_PID=$!
    fi

    if [ -n "$NOUPDATE" ]; then
        exit 0
    fi

    sleep "$UPDATE_FREQ"

    # Update START/END time
    END="$(bc -l <<< "$END + $UPDATE_FREQ")"
    if [ -z "$REALTIME" ]; then
        END="$(AWK -v last_update="$(rrdtool last "$DB")" \
                '{ print (last_update > $1) ? last_update : $1 }' <<< "$END")"
    fi
    if [ -z "$ALL" ]; then
        START="$(bc -l <<< "$END - $INTERVAL")"
    fi

    if ! ps -p "$IMAGE_VIEWER_PID" &> /dev/null; then
        # Image viewer process was terminated, exit
        exit 1
    fi
done
